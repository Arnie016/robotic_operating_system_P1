\documentclass[11pt,a4paper]{article}

\usepackage[margin=0.95in]{geometry}
\usepackage{graphicx}
\usepackage{amsmath,amssymb}
\usepackage{float}
\usepackage{hyperref}
\usepackage{setspace}
\usepackage{caption}
\usepackage{booktabs}

\hypersetup{
  colorlinks=true,
  linkcolor=black,
  urlcolor=blue,
  citecolor=black
}

\setlength{\parskip}{0.22em}
\setlength{\parindent}{0em}
\setstretch{1.03}
\setcounter{tocdepth}{1}

\title{EE4308 Project 1 Report\\Designing Nav2 Controller and Planner Plugins}
\author{Arnav Salkade\\Matric No.: \texttt{[YOUR MATRIC]}}
\date{February 2026}

\begin{document}

\pagenumbering{arabic}
\setcounter{page}{1}
\maketitle

\vspace{-0.9em}
{\small\setstretch{0.94}\tableofcontents}
\newpage

\section*{Word Count Summary}
\addcontentsline{toc}{section}{Word Count Summary}
Word counts below are reported for this draft to improve submission control and page budgeting. The counts were computed from section text and exclude the reference list.

\begin{table}[H]
\centering
\caption{Section-wise word counts (references excluded)}
\begin{tabular}{lr}
\toprule
Section & Words \\
\midrule
Abstract & 133 \\
Introduction & 192 \\
Methodology and Evaluation Design & 178 \\
Controller: Implementation and Reasoning & 419 \\
Planner: Implementation and Reasoning & 523 \\
Parameter Tuning, Counter-cases, and Final Settings & 195 \\
Results and Discussion & 143 \\
Further Work & 92 \\
Conclusion & 146 \\
\midrule
Total (excluding references) & 2021 \\
\bottomrule
\end{tabular}
\end{table}

\newpage

\section{Abstract}
This report presents the design and tuning of custom Nav2 controller and planner plugins for EE4308 Project 1, with emphasis on reproducible reasoning rather than parameter trial-and-error. The controller was implemented as regulated pure pursuit with explicit handling of lookahead adaptation, curvature-based speed regulation, proximity-based speed regulation from laser data, and terminal orientation alignment. The planner was implemented as A* search over a costmap with robust coordinate conversion, accessibility filtering, diagonal corner-cut prevention, and path post-processing through densification and Savitzky--Golay smoothing. The final behavior improved corridor tracking stability, reduced inflation-zone hugging, and produced more consistent near-goal convergence. The most important outcome is methodological: each change was motivated by a diagnosed cause, validated against map geometry, and then integrated only after preserving controller compatibility. This cause-first workflow improved both navigation performance and technical explainability.

\section{Introduction}
Project 1 required a complete navigation chain where the robot must generate feasible paths and track them reliably under constrained geometry. Achieving this objective depends on more than implementing textbook algorithms in isolation. In practice, small interface issues between planner output and controller assumptions often dominate runtime behavior, particularly in narrow corridors and near inflated obstacles. The implementation in this report therefore treated planner and controller as a coupled system rather than independent components.

Two recurring observations shaped the development process. First, smooth-looking paths were not always safe paths: some visually smooth trajectories approached high-cost inflation zones too aggressively and produced unstable local tracking corrections. Second, successful runs were highly sensitive to path structure, especially waypoint density and corner geometry. These observations motivated a structured methodology where every modification was linked to an explicit hypothesis about the underlying failure mechanism.

The final architecture places the controller analysis first because it defines the geometric and dynamic constraints that planner output must satisfy. The planner section then explains how the search and post-processing pipeline was redesigned to produce trajectories that are not only feasible in the map, but also trackable under regulated pure pursuit.

\section{Methodology and Evaluation Design}
The tuning workflow followed controlled ablation instead of unconstrained multi-parameter search. A baseline run was executed, one dominant failure mode was isolated, one implementation or parameter change was introduced, and the same run conditions were repeated. This process was applied across turn-entry behavior, near-goal behavior, and corridor traversal before any additional optimizations were considered.

Evaluation focused on operational criteria that directly reflect project requirements. Path feasibility was defined as map-consistent output with no out-of-bounds coordinates and no obstacle-crossing shortcuts. Tracking quality was defined by smooth heading evolution, low oscillation near turns, and stable goal convergence with final-yaw alignment. Safety behavior was assessed through inflation interaction, especially whether trajectories remained in low-to-moderate cost regions instead of riding high-cost bands.

Although the report is primarily qualitative, each qualitative claim is tied to a concrete mechanism. For example, when inflation hugging was observed, the analysis examined thresholding and costmap coupling rather than only adjusting controller gains. When corner instability appeared, the analysis examined lookahead geometry and path sampling density before changing angular limits. This discipline reduced tuning noise and improved interpretability.

\section{Controller: Implementation and Reasoning}
\subsection{Command Pipeline and Geometric Foundation}
The controller core is implemented in \texttt{computeVelocityCommands()} as a deterministic sequence. It first validates availability of a global path and returns zero command on invalid input, then evaluates whether the robot has reached positional proximity to goal, and finally executes either terminal alignment logic or path-following logic. This sequencing avoids contradictory command outputs between translational tracking and terminal rotation.

For tracking mode, the controller identifies the closest point on the path and then searches forward toward the goal for the lookahead point. This directionality is critical because nearest Euclidean proximity is not sufficient in maps with corridors and turns; searching from the wrong direction can select points that are geometrically close but path-inconsistent. The selected lookahead point is transformed to robot frame $(x',y')$, and curvature is computed as
\begin{equation}
\kappa = \frac{2y'}{L^2}, \qquad L = \sqrt{x'^2+y'^2}.
\end{equation}
Angular velocity is then computed from
\begin{equation}
\omega = v\kappa.
\end{equation}
This formulation is efficient, but highly sensitive to path sampling density and lookahead policy, which is why planner-side post-processing was treated as a controller requirement rather than a cosmetic enhancement.

\subsection{Regulated Pure Pursuit Heuristics}
The regulated extension introduces three coupled mechanisms. The first is adaptive lookahead, defined by
\begin{equation}
L_h = g_l\,v,
\end{equation}
where $g_l$ is the lookahead gain. The second is curvature regulation, which reduces linear speed in high-curvature conditions to prevent overshoot and delayed heading recovery. The third is proximity regulation, which reduces speed when laser-derived obstacle distance falls below a proximity threshold.

The reasoning for joint tuning is straightforward: increasing lookahead generally lowers instantaneous curvature demand, which can reduce curvature-triggered slowdown and increase turn-entry speed. If proximity regulation is simultaneously weak, the robot enters constrained regions too aggressively. Conversely, if curvature and proximity regulation are both overly conservative, traversal becomes inefficient and may trigger repeated micro-corrections near the terminal pose. The final controller behavior was obtained by balancing these couplings rather than optimizing each parameter independently.

\subsection{Terminal Orientation and Near-goal Stability}
Project requirements include final orientation alignment, not only positional arrival. The controller therefore transitions into a dedicated terminal mode when positional error is below \texttt{xy\_goal\_thresh\_}. In this mode, if heading error remains above \texttt{yaw\_goal\_thresh\_} ($0.25\\,\\mathrm{rad}$ in the project spec), the controller commands pure rotation and suppresses translational motion. This prevents stop-with-wrong-yaw behavior and avoids unnecessary path re-acquisition attempts in the final meter.

Near-goal oscillation was treated as a combined geometry-control problem. If lookahead is too short and angular authority too high, heading corrections can alternate rapidly. If lookahead is too long, final alignment may be delayed. The final tuning retained stable approach while preserving deterministic final yaw lock, which was one of the most sensitive acceptance criteria in repeated test runs.

\section{Planner: Implementation and Reasoning}
\subsection{A* Search, Data Structures, and Coordinate Reliability}
The planner uses A* with evaluation
\begin{equation}
f(n) = g(n) + h(n),
\end{equation}
implemented over an 8-connected grid. A priority queue stores candidate nodes by minimum $f$, parent pointers are retained for path reconstruction, and expansion flags prevent repeated full expansion of stale queue entries. Cost relaxation is allowed, so lower-cost rediscovery of a node can update its parent and queue priority before expansion.

Coordinate handling was implemented explicitly to avoid hidden indexing faults. World-to-cell conversion uses map origin and resolution with flooring, cell-to-world conversion targets cell centers, row-major flattening maps $(c,r)$ to storage index, and out-of-map checks gate every neighbor access. These helpers are conceptually simple but practically central; failures in this layer often appear downstream as inexplicable controller behavior.

\subsection{Heuristic Selection and Practical Dominance}
Heuristic design considered admissibility, consistency behavior under the chosen expansion logic, and practical informativeness for 8-connected motion. Manhattan distance was too conservative for diagonal traversal and produced broader expansions. Euclidean distance improved directionality. Octile distance provided the best alignment with available motion primitives and was therefore selected:
\begin{equation}
h(n) = (\max(\Delta c,\Delta r)-\min(\Delta c,\Delta r)) + \sqrt{2}\,\min(\Delta c,\Delta r),
\end{equation}
where $\Delta c = |c-c_g|$ and $\Delta r = |r-r_g|$.

In repeated corridor scenarios, this heuristic reduced unnecessary expansion and made goal-oriented progression more consistent without introducing overestimation risks.

\subsection{Accessibility Threshold and Inflation Coupling}
The parameter \texttt{max\_access\_cost} defines which cells are considered traversable. This threshold strongly controls clearance behavior. High threshold values produce permissive paths that may hug inflation zones. Low threshold values increase clearance but may over-prune narrow passages. The parameter was therefore tuned as part of a coupled map-safety system together with inflation characteristics, not as an isolated planner constant.

This coupling explains a common counter-case: reducing threshold can improve safety in open corridors but fail in legitimate narrow transitions where inflation consumes most free cells. The chosen operating window balanced these competing failure modes.

\subsection{Corner-cut Prevention and Geometric Validity}
A major failure mode in 8-connected planning is diagonal corner cutting. A diagonal move can appear valid at endpoint cells while crossing blocked geometry between them. To eliminate this, diagonal transitions were accepted only if both adjacent orthogonal side cells were below accessibility threshold. This modification removed wall-clipping behavior around L-junctions and produced paths that were slightly longer but consistently trackable.

This change had a strong downstream effect on controller behavior because geometrically valid corners reduce abrupt corrective steering and limit curvature spikes induced by last-moment obstacle avoidance.

\subsection{Path Reconstruction, Densification, and Smoothing}
After goal expansion, the path is reconstructed by parent backtracking and reversed into start-to-goal order. Frame consistency is preserved and terminal pose is explicitly restored to the requested goal pose to prevent endpoint drift from post-processing. This endpoint enforcement is essential when smoothing is enabled.

The planner then applies densification to reduce segment sparsity. For segment length $d$ and interpolation distance $d_{\text{interp}}$, interpolation count is
\begin{equation}
N = \max\left(1,\left\lceil\frac{d}{d_{\text{interp}}}\right\rceil\right).
\end{equation}
Densification improves controller compatibility by reducing heading discontinuities between adjacent waypoints.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.92\linewidth]{\detokenize{Densification block within planner.png}}
    \caption{Planner densification implementation used to increase waypoint frequency.}
    \label{fig:densification_block}
\end{figure}

Savitzky--Golay smoothing was then applied to suppress grid staircase artifacts while preserving local trajectory trend. With half-window $m$ and polynomial order $p$, the filter kernel is derived from the Vandermonde system
\begin{equation}
\mathbf{A}=(\mathbf{J}^{\top}\mathbf{J})^{-1}\mathbf{J}^{\top}.
\end{equation}
This stage improved heading continuity but introduced known risks: high-order fits can oscillate, large windows can flatten important turns, and unconstrained smoothing can drift endpoints. The final implementation constrained $(m,p)$ ranges and preserved terminal anchors to prevent these counter-cases.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.82\linewidth]{\detokenize{Savitzky-Golay smoother implementation.png}}
    \caption{Savitzky--Golay smoothing block integrated into planner post-processing.}
    \label{fig:sg_block}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{minipage}[t]{0.49\linewidth}
        \centering
        \includegraphics[width=\linewidth]{\detokenize{m=30 p=20, (b) m=20, p=5.png}}
    \end{minipage}\hfill
    \begin{minipage}[t]{0.49\linewidth}
        \centering
        \includegraphics[width=\linewidth]{\detokenize{part 1 m=30 p=20, (b) m=20, p=5.png}}
    \end{minipage}
    \caption{Combined comparison of smoothing outcomes under different $(m,p)$ settings in two map contexts.}
    \label{fig:mp_compare_combined}
\end{figure}

\section{Parameter Tuning, Counter-cases, and Final Settings}
Tuning was executed in causal order rather than by random grid search. \texttt{max\_access\_cost} was first tuned to suppress inflation hugging while preserving narrow-corridor feasibility. \texttt{interpolation\_distance} was then tuned to stabilize controller lookahead sampling. Smoothing parameters $(m,p)$ were tuned next, with strict avoidance of overfitting and endpoint drift. Only after planner output quality stabilized were controller regulation parameters refined.

For the controller, lookahead gain $g_l$ was set to avoid both extreme skipping and jitter. Curvature threshold was tuned to reduce turn-entry overshoot without excessively reducing throughput in mild curvature segments. Proximity threshold was tuned to activate conservative behavior in constrained zones without collapsing velocity in open lanes. Goal thresholds were tuned to preserve deterministic final orientation behavior and suppress oscillatory micro-corrections at low speed.

Each parameter had a specific counter-case. Excessive accessibility threshold caused inflation hugging. Excessively small threshold blocked valid corridors. Too large interpolation spacing produced sparse references and reactive steering. Too small spacing increased computation without proportional gain. Large $m$ with high $p$ produced visually smooth but operationally risky paths near obstacles. Very low lookahead improved responsiveness but amplified angular jitter. Very high lookahead reduced jitter but delayed turning. The final settings were chosen where these counter-cases were simultaneously bounded.

\section{Results and Discussion}
The final integrated stack produced consistent path feasibility and stable tracking in corridor and bend transitions. Corner-cut prevention eliminated the most severe geometric invalidities that previously propagated into controller instability. Densification and constrained smoothing reduced heading discontinuities, which improved regulated pure pursuit behavior under identical control limits.

A recurring practical observation was occasional first-run instability followed by normal behavior on subsequent attempts. The most plausible mechanism was startup synchronization of TF and costmap readiness. This was operationally mitigated by delaying first goal dispatch and verifying map readiness before execution. While this is not an algorithmic fix, it improved reproducibility during evaluation and reduced false negatives in testing.

Overall, the implementation met project intent by combining algorithmic correctness with operational robustness. The key lesson is that navigation quality depends on the compatibility of planner output with controller geometry, not only on isolated local improvements.

\section{Further Work}
The immediate next step is to complement qualitative findings with structured quantitative evidence. Repeated trials on fixed routes should report success rate, completion time distribution, peak curvature demand, and minimum obstacle clearance. This would convert the current causal narrative into statistically grounded comparison.

A second extension is broader map diversity. Current tuning is strong in corridor-dominant layouts; additional evaluation on open cluttered scenes and asymmetric bottlenecks would test generalization. If runtime budget permits, adaptive scheduling of lookahead and smoothing aggressiveness based on local map complexity can further improve robustness without sacrificing efficiency.

\section{Conclusion}
This project demonstrates that robust navigation is achieved through planner-controller co-design. The controller required regulated pure pursuit with careful geometric sequencing and terminal-yaw logic. The planner required reliable coordinate infrastructure, search validity checks, corner-cut prevention, and post-processing tuned for controller compatibility. The final result was not the product of one algorithmic change but of a disciplined tuning process that linked observations to causes and causes to targeted modifications.

The report therefore emphasizes engineering reasoning as much as implementation. By documenting counter-cases and trade-offs explicitly, the final system becomes easier to justify, reproduce, and improve in future assignments.

\clearpage
\section*{References}
EE4308 Project 1 specification, AY25/26 Sem 2, National University of Singapore.\\
EE4308 Week 2 lecture notes, Motion and Mapping.\\
EE4308 Week 3 lecture notes, Planners.\\
EE4308 Week 4 lecture notes, Trajectories and Motion Control.\\
S. Dolgov et al., ``Practical Search Techniques in Path Planning for Autonomous Driving,'' 2008.

\end{document}
