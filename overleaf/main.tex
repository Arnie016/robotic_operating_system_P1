\documentclass[11pt,a4paper]{article}

\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{amsmath,amssymb}
\usepackage{booktabs}
\usepackage{siunitx}
\usepackage{float}
\usepackage{hyperref}
\usepackage{setspace}
\usepackage{caption}

\hypersetup{
  colorlinks=true,
  linkcolor=black,
  urlcolor=blue,
  citecolor=black
}

\setlength{\parskip}{0.6em}
\setlength{\parindent}{0em}
\onehalfspacing

\title{EE4308 Project 1 Report Draft\\Designing and Tuning Nav2 Planner and Controller Plugins}
\author{Arnav Salkade, Harsh Ahuja, Patrick Joy Surbakti\\Matric Nos.: \texttt{A0273648N}, \texttt{A0312072W}, \texttt{A0266288M}}
\date{February 2026}

\begin{document}
\maketitle
\tableofcontents
\newpage

\section{Introduction}
This report documents the implementation and tuning of a custom planner-controller stack for EE4308 Project 1 in ROS 2 Nav2. The project objective is not only to produce a valid path from start to goal, but to ensure that the robot follows that path stably, avoids obstacle-rich regions with adequate clearance, and reaches the goal with correct terminal orientation. The final system combines an A* global planner, path densification and Savitzky--Golay smoothing, and a regulated pure pursuit controller with explicit final-yaw alignment logic.

The implementation process was driven by repeated failure analysis rather than single-pass parameter tweaking. Each major change was motivated by a specific observed issue, including first-run planning inconsistency, corner cutting at diagonal transitions, inflation-zone hugging, and oscillatory behavior near bends or at the goal. For each issue, the algorithmic cause was traced first, then parameter changes were applied in a constrained manner to isolate effects. This cause-to-effect workflow significantly improved repeatability and prevented overfitting to one map or one successful run.

\section{System Architecture and Methodology}
The navigation pipeline begins with the planner producing a global path on a costmap. That path is then post-processed to improve geometric quality before being consumed by the controller. The controller transforms the local segment of the path into the robot frame, computes geometric curvature toward a lookahead point, and regulates linear and angular commands with curvature and proximity heuristics. A separate terminal condition handles final orientation alignment, since pure pursuit tracking alone does not guarantee precise goal yaw.

Methodologically, tuning was performed in a strict order to reduce confounding effects. Planner safety and path validity were corrected before any controller gains were adjusted. Path geometry quality was improved through densification and smoothing only after path validity checks were stable. Controller regulation was tuned after global path quality became predictable. This ordering was necessary because controller instability can be a symptom of poor global path geometry, and not always a controller defect.

\section{Planner Design}
The global planner is based on A* search, where node priority is computed as $f(n)=g(n)+h(n)$. Here, $g(n)$ is the accumulated traversal cost and $h(n)$ is an estimate of remaining cost to the goal. Since the map is expanded with 8-connected motion primitives, octile distance was selected as the final heuristic:
\begin{equation}
h(n)=\left(\max(\Delta c,\Delta r)-\min(\Delta c,\Delta r)\right)+\sqrt{2}\,\min(\Delta c,\Delta r),
\end{equation}
where $\Delta c$ and $\Delta r$ are absolute column and row differences between node $n$ and goal cell. Octile distance was chosen because it aligns with mixed axial-diagonal stepping and yielded fewer unnecessary expansions in corridor-heavy maps than Manhattan distance.

Two implementation details were critical for reliability. First, robust coordinate conversion utilities were used for world-to-cell and cell-to-world mappings, with explicit out-of-map checks before indexing cost arrays. Second, start and goal validity checks were added before search expansion begins. If either pose is out of bounds or lies in a cell above the accessibility threshold, planning is rejected early and an empty path is published. This behavior avoids undefined downstream controller states and keeps runtime behavior deterministic.

Path reconstruction is implemented by backtracking parent pointers from goal to start and then reversing the sequence to obtain start-to-goal ordering. A previous source of inconsistency was mismatched header handling after reconstruction. In the final version, frame and timestamp are propagated consistently and the terminal pose is explicitly overwritten with the exact user goal pose so that downstream final-yaw logic has a correct reference.

An additional design comparison was considered between A* and Theta*. Theta* can produce shorter any-angle paths by allowing line-of-sight parent rewiring, and therefore may appear smoother even before post-processing. However, this gain comes with stricter and more frequent visibility checks, and in costmap-heavy indoor navigation it can trade geometric elegance for reduced predictability near inflated boundaries if not tightly constrained. For this project scope, A* with explicit corner-cut prevention, densification, and constrained smoothing provided a more controllable pipeline and made the effect of each tuning parameter easier to interpret during debugging.

\section{Corner-Cutting Prevention and Access-Cost Logic}
One of the earliest failure modes was diagonal wall clipping, where the planner selected a diagonal transition between two inflated or blocked side cells. This behavior is geometrically invalid for a robot footprint and appears as corner cutting in RViz. The fix was to reject diagonal neighbor transitions when either orthogonally adjacent side cell is inaccessible. For a diagonal step $(\Delta c,\Delta r)$ from cell $(c,r)$, the transition is discarded if $\text{cost}(c+\Delta c,r)\geq T$ or $\text{cost}(c,r+\Delta r)\geq T$, where $T$ is \texttt{max\_access\_cost}.

The accessibility threshold itself had to be tuned with care. High values made the planner permissive and allowed the path to hug inflation gradients very closely, which looked feasible in map space but reduced execution robustness. Lower values increased clearance but could reject narrow passage solutions if set too conservatively. In practice, values around 150--160 produced a balanced result in tested maps, while 140 was used when inflation hugging remained visually strong. When narrow passages became unreachable, the threshold was raised incrementally toward 170--180. This range was evaluated together with inflation settings rather than in isolation, because clearance behavior is jointly determined by both layers.

\section{Path Densification and Smoothing}
Raw A* paths on grid maps are typically sparse and piecewise linear, which causes abrupt heading changes at the controller input. Densification was introduced before smoothing to increase waypoint resolution along each segment. For segment length $d$ and interpolation spacing $d_{\text{interp}}$, the number of inserted samples is:
\begin{equation}
N=\max\left(1,\left\lceil\frac{d}{d_{\text{interp}}}\right\rceil\right).
\end{equation}
This step improved tracking continuity because lookahead search had more geometrically meaningful candidates near turns.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\linewidth]{\detokenize{Densification block within planner.png}}
    \caption{Path densification implementation in the planner post-processing stage.}
    \label{fig:densification_block}
\end{figure}

Savitzky--Golay smoothing was then applied to densified path coordinates to suppress grid-induced jaggedness while preserving local trend structure. With half-window $m$ and polynomial order $p$, the smoothing kernel is derived from the Vandermonde system and applied as a discrete convolution on $x$ and $y$ sequences. In implementation terms, this stage must be constrained because unconstrained smoothing can shift points toward inflated regions or distort terminal geometry.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.82\linewidth]{\detokenize{Savitzky-Golay smoother implementation.png}}
    \caption{Savitzky--Golay smoother implementation used for path post-processing.}
    \label{fig:sg_block}
\end{figure}

The observed parameter behavior was consistent across repeated tests. Larger $m$ improved visual smoothness but flattened sharp turns and increased risk near narrow inflated gaps. Larger $p$ preserved local detail only up to a point; beyond moderate values it began to overfit local noise and produced unstable oscillatory geometry. In extreme settings, the smoothed path deviated enough to violate map feasibility. These failures explain why smoothing should not be judged solely by visual appeal. The accepted configuration favored moderate polynomial order with conservative window size, and start-goal endpoint consistency was enforced after smoothing.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\linewidth]{\detokenize{m=30 p=20, (b) m=20, p=5.png}}
    \caption{Example comparison showing aggressive versus moderate smoothing parameter behavior.}
    \label{fig:mp_compare_main}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\linewidth]{\detokenize{part 1 m=30 p=20, (b) m=20, p=5.png}}
    \caption{Additional comparison of trajectory shape under different Savitzky--Golay settings.}
    \label{fig:mp_compare_part1}
\end{figure}

\section{Controller Design and Tracking Logic}
The controller follows a regulated pure pursuit formulation. A lookahead target is selected from the global path after transforming candidate points into the robot frame. Curvature is computed as
\begin{equation}
\kappa=\frac{2y'}{L^2}, \qquad L=\sqrt{x'^2+y'^2},
\end{equation}
and angular command is generated from $\omega=v\kappa$. A central implementation requirement is that lookahead selection must begin from the closest path point and progress toward the goal direction. This prevents pathological choices when global path updates lag or when spatially nearby points belong to disconnected regions.

Regulation is applied on top of pure pursuit to improve physical behavior. Variable lookahead uses speed-dependent scaling to reduce overreaction at higher speed and improve precision at lower speed. Curvature-based velocity regulation decreases linear speed when required turning curvature increases, limiting overshoot in sharp turns. Proximity-based regulation reduces speed when laser-derived obstacle distance falls below a threshold, which adds a reactive safety buffer in cluttered areas. These mechanisms were tuned jointly because over-conservative proximity limits can mask poor curvature tuning and vice versa.

Final goal handling is split into position and orientation phases. When position error enters the goal radius but yaw error remains above threshold, the controller transitions to pure rotation mode until terminal heading converges. This decoupling removed the common failure where the robot stops with acceptable position but incorrect orientation. The project threshold requirement for yaw was retained at \texttt{yaw\_goal\_thresh\_}=0.25 rad and verified against final pose behavior in repeated runs.

Goal completion quality also depended strongly on the position threshold, \texttt{xy\_goal\_thresh\_}. If this threshold is too small, practical odometry noise and minor heading correction can keep the robot outside completion criteria and induce oscillatory micro-corrections near the target. If it is too large, the robot may terminate early and rely excessively on final rotation at an offset position. The adopted strategy was to tune \texttt{xy\_goal\_thresh\_} together with \texttt{yaw\_goal\_thresh\_} so that translational convergence occurs before orientation-only mode, while avoiding repeated mode switching near the goal boundary.

\section{Parameter Discussion, Counter-Cases, and Tuning Outcomes}
Planner and controller tuning were evaluated with explicit counter-cases rather than only successful trajectories. For planner access threshold, the positive case was safe corridor centering, while the counter-case was loss of feasibility in tight passages when threshold was too low. For interpolation distance, the positive case was improved path-following continuity, while the counter-case was increased computational load and occasional over-constrained smoothing behavior when spacing became too fine. For smoothing parameters $(m,p)$, the positive case was reduced local jaggedness, while the counter-case was collision-risk drift and path distortion under aggressive settings.

On the controller side, increasing lookahead gain improved smoothness on long straights but caused turn-miss behavior in compact maps by skipping informative near-field points. Reducing lookahead gain improved corner tracking but introduced jitter if combined with high angular aggressiveness. Curvature regulation reduced overshoot but could produce sluggish behavior if thresholding was too conservative. Proximity regulation improved safety near obstacles but could cause excessive slowdown and stop-go motion in narrow corridors when set too high. The final configuration was selected from this trade-space by favoring robust repeatability over single-run speed.

The first-run failure followed by second-run success pattern was treated as a system-state issue rather than planner randomness. The dominant cause was startup synchronization of costmap and transform availability during early goal dispatch. A short post-bringup wait before sending the first goal consistently reduced this issue. This observation matters for grading because occasional startup misses can be misinterpreted as algorithmic instability unless the execution protocol is controlled.

\section{Experimental Protocol and Evidence Strategy}
To support the EE4308 expectation of explanation with evidence, each parameter change was tested with repeated runs and paired against a baseline. The baseline was recorded before modification, then one parameter was changed at a time while holding others fixed. This isolated each effect and prevented false attribution. For each run, qualitative observations were tied to measurable criteria: whether the path entered inflated margins, whether the robot oscillated near the goal, whether final yaw alignment completed, and whether stopping behavior remained stable.

Evidence artifacts were selected to represent implementation logic and behavior outcomes together. Code-level screenshots were used to document densification and smoothing implementation. Parameter comparison figures were used to show how smoothing aggressiveness changes trajectory geometry. In the final version, these artifacts should be complemented by run logs and short RViz/video snapshots linked directly to the parameter set used for that run, so that explanation and evidence remain traceable.

\section{Limitations and Further Actions}
Although the current implementation is stable for the tested scenarios, two limitations remain. First, smoothing safety is primarily controlled by parameter conservatism; a stronger implementation would add a hard collision-aware fallback that keeps original points whenever smoothed points exceed access threshold. Second, controller regulation is tuned for the current map and robot constraints; broader generalization should be verified across maps with different corridor widths and obstacle density.

The next practical actions are to formalize a results table with repeated trial counts, success rates, and mean terminal errors for each major tuning stage, then align those quantitative results directly to equations and algorithm choices in the report narrative. This will strengthen grading under the cause-effect rubric and reduce the risk of the report being perceived as generic. A final pass should also align wording to team contribution boundaries and attach explicit parameter snapshots from \texttt{proj1.yaml} for reproducibility.

\section{Conclusion}
The project outcome demonstrates that robust navigation performance depends on coupling algorithmic correctness with disciplined tuning methodology. A* planning alone is insufficient when diagonal validity, inflation-aware accessibility, and path geometry quality are not handled carefully. Likewise, pure pursuit alone is insufficient without regulation and final-yaw handling. By integrating corner-cut prevention, densification, constrained Savitzky--Golay smoothing, and regulated pure pursuit logic, the system achieved stable and feasible behavior in the tested environments.

The main technical lesson is that successful tuning must begin from implementation causes, not only visual effects. Every stable improvement in this project came from tracing an observed failure to a specific algorithmic mechanism, validating that mechanism with controlled tests, and only then locking parameter values.

\section*{Member Contribution}
Arnav Salkade (Matric: \texttt{A0273648N}) focused on planner implementation, path post-processing, and planner parameter tuning. Harsh Ahuja (Matric: \texttt{A0312072W}) focused on regulated pure pursuit implementation, lookahead and velocity regulation tuning, and final-yaw behavior. Patrick Joy Surbakti (Matric: \texttt{A0266288M}) focused on experiment execution, logging, evidence curation, and report integration.

\section*{References}
\begin{enumerate}
    \item EE4308 Project 1 specification (\texttt{proj1.md}), AY25/26 Sem 2.
    \item EE4308 lecture notes: Motion and Mapping.
    \item EE4308 lecture notes: Planners.
    \item EE4308 lecture notes: Trajectories and Motion Control.
    \item S. Dolgov et al., ``Practical Search Techniques in Path Planning for Autonomous Driving,'' 2008.
\end{enumerate}

\end{document}
